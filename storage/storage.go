package storage

import (
	"bytes"
	"fmt"
	"io"
	"log"
	"os"
	"strings"
	"sync"
)

type Storage struct {
	StorageOptions
	mu sync.Map // Map to store mutexes for each key
}

func NewStorage(options StorageOptions) *Storage {
	if options.PathTransformFunc == nil {
		options.PathTransformFunc = DefaultPathTransformFunc

		options.Logger.Info("PathTransformFunc not provided. Using DefaultPathTransformFunc")
	}

	return &Storage{
		StorageOptions: options,
	}
}

func (s *Storage) getMutex(key string) *sync.Mutex {
	mu, _ := s.mu.LoadOrStore(key, &sync.Mutex{})
	return mu.(*sync.Mutex)
}

// WriteStream writes the file to the disk. The caller is responsible for closing the io.Reader passed to it.
func (s *Storage) WriteStream(key string, r io.Reader) error {
	mutex := s.getMutex(key)
	mutex.Lock()
	defer func() {
		mutex.Unlock()
		s.Logger.Infof("Unlocked mutex for key : %s", key)
	}()

	s.Logger.Infof("Locked mutex for key: %s to write into the directory generated by it.", key)

	pathName, fileName := s.PathTransformFunc(s.StorageRoot, key)

	// create the directory if doesn't exist
	if err := os.MkdirAll(pathName, os.ModePerm); err != nil {
		return fmt.Errorf("error while creating directory %s and err: %s", pathName, err.Error())
	}

	pathWithFileName := pathName + "/" + fileName
	s.Logger.Infof("Created directory: %s", pathName)

	file, err := os.Create(pathWithFileName)
	if err != nil {
		return fmt.Errorf("error while creating file %s and err: %s", fileName, err.Error())
	}

	s.Logger.Infof("Created File : %s", pathWithFileName)

	_, err = io.Copy(file, r)
	if err != nil {
		return fmt.Errorf("error while copying data to file %s and err: %s", fileName, err.Error())
	}

	s.Logger.Infof("Copied data to file: %s", pathWithFileName)

	err = file.Close()
	if err != nil {
		return fmt.Errorf("error while closing file %s and err: %s", fileName, err.Error())
	}

	return nil
}

// ReadStream reads the file from the disk and returns the file as an io.Reader.
// The caller is responsible for closing the returned io.Reader.
func (s *Storage) ReadStream(key string) (io.Reader, error) {
	mutex := s.getMutex(key)
	mutex.Lock()
	defer func() {
		mutex.Unlock()
		s.Logger.Infof("Unlocked mutex for key : %s", key)
	}()

	s.Logger.Infof("Locked mutex for key: %s to read from the directory generated by it.", key)

	pathName, fileName := s.PathTransformFunc(s.StorageRoot, key)
	pathWithFileName := pathName + "/" + fileName

	file, err := os.Open(pathWithFileName)
	if err != nil {
		return nil, fmt.Errorf("error while opening file %s and err: %s", pathWithFileName, err.Error())
	}

	s.Logger.Infof("Opened file: %s", pathWithFileName)

	defer file.Close()

	buf := new(bytes.Buffer)
	_, err = io.Copy(buf, file)
	if err != nil {
		return nil, fmt.Errorf("error while copying file content: %s", err.Error())
	}

	s.Logger.Infof("Read file content from file: %s", pathWithFileName)

	return buf, nil
}

func (s *Storage) Has(key string) bool {
	pathName, fileName := s.PathTransformFunc(s.StorageRoot, key)
	pathWithFileName := pathName + "/" + fileName

	log.Printf("Checking existence of file: %s", pathWithFileName)

	_, err := os.Stat(pathWithFileName)
	return err == nil
}

// Delete deletes the file from the disk
func (s *Storage) Delete(key string) error {
	mutex := s.getMutex(key)
	mutex.Lock()
	defer func() {
		mutex.Unlock()
		s.Logger.Infof("Unlocked mutex for key : %s", key)
	}()

	s.Logger.Infof("Locked mutex for key: %s to delete from the directory generated by it.", key)

	if !s.Has(key) {
		return fmt.Errorf("file not found for key: %s ", key)
	}

	pathName, fileName := s.PathTransformFunc(s.StorageRoot, key)
	pathWithFileName := pathName + "/" + fileName

	err := os.Remove(pathWithFileName)
	if err != nil {
		return err
	}

	s.Logger.Infof("Deleted file: %s successfully", pathWithFileName)

	return nil
}

func (s *Storage) CleanPath(path string) bool {
	paths := strings.Split(path, "/")
	return s.recursiveClean(0, "", &paths)
}

func (s *Storage) recursiveClean(i int, path string, paths *[]string) bool {
	// Base case: If we've processed all paths, return true.
	if i == len(*paths) {
		return true
	}

	// Add the current directory to the path
	path += "/" + (*paths)[i]

	// Log the current path being processed
	s.Logger.Infof("RecursiveClean with Path: %s", path)

	// First, process the next level of subdirectories (recursively).
	if !s.recursiveClean(i+1, path, paths) {
		return false
	}

	// Now, check if the current directory is empty by reading its contents.
	dirContents, err := os.ReadDir(path[1:])
	if err != nil {
		s.Logger.Warnf("Failed to read directory %s: %v", path, err)
		return false
	}

	// If the directory is not empty, don't remove it.
	if len(dirContents) > 0 {
		s.Logger.Warnf("Directory %s is not empty. Skipping removal.", path)
		return true
	}

	// If the directory is empty, remove it.
	if err = os.RemoveAll(path[1:]); err == nil {
		s.Logger.Warnf("Failed to remove directory %s: %v", path, err)
		return true
	}

	// Log successful deletion.
	s.Logger.Infof("Directory %s is empty, deleting", path)
	return false
}
